/*
 *
 * Copyright (c) 1996-2018 McAfee, LLC. All Rights Reserved.
 * 
 * Type definitions required by Olympus scanning engine.
 *
 * 
 */

#ifndef AVTYPES__H
#define AVTYPES__H

#ifdef __cplusplus
extern "C" {
#endif 

/*******************
 *                 *
 * Include files.  *
 *                 *
 *******************/


#include <stddef.h>

#include "avcodes.h"    /* Olympus parameters definitions. */
#include "avmacro.h"    /* Common macro definitions. */

#if !defined UNIX
/* Define structure packing for various compilers - must be 4 byte aligned !! */
	#ifdef MacOS
	   #pragma options align = mac68k
    #else
        #pragma pack(4)
	#endif
#endif



/********************
 *                  *
 * Type definitions.*
 *                  *
 ********************/

/* Handle to engine.  */
typedef void* HENGINE;
#define HENGINE_DEFINED         /* just to let VIRSCAN.H know that the type "HENGINE" is defined */

/* Handle to scanner. Casts to AV_ENGINEHANDLE structure. */
typedef void* HSCANNER;

/* AV_ERROR lists the types of errors that can be generated by the engine. */
typedef WORD AV_ERROR;
#define AVE_SUCCESS 0               /* Success */
#define AVE_CRITICALERROR 1         /* Terminate immediately */
#define AVE_UNSUPPORTEDCALL 2       /* This platform does not support this function */
#define AVE_BADPARAMETER 3          /* Parameter passed invalid. */
#define AVE_OUTOFMEMORY 4           /* An allocation operation failed. */
#define AVE_INVALIDSCANOBJECT 5     /* Request made to scan an object that did not exist etc. */
#define AVE_READERROR 6             /* Read error on boot/partition/file scan. */
#define AVE_LOADFAILURE 7           /* Support DLL load failed. e.g. RWABS32.DLL missing. */
#define AVE_DRIVERFAILURE 8         /* Virus Driver failed. e.g. SCAN.DAT missing. */
#define AVE_USERTERMINATED 9        /* User quit program (in response to AVM_QUERYTERMINATE usually) */
#define AVE_MISMATCHEDDRIVERS 10    /* The DAT files are not all the same version */
#define AVE_CORRUPTEDFILE 11        /* A corrupted archive file error. */
#define AVE_EXPIREDLIFE 12          /* Engine has expired - needs updating */
#define AVE_APIVERSION 13           /* A feature of a different version API was requested */
#define AVE_INFONOTAVAILABLE 14     /* No information available for AVRetrieveInstanceInfo */
#define AVE_DUPLICATEPARAMETER 15   /* A parameter was passed more than once in the same AV_PARAMETERS structure. */
#define AVE_INVALIDHANDLE 16        /* The HENGINE passed to an API function was not valid. */
#define AVE_UPDATEFAILED 17         /* An error occured during updating the DATs */

/*
 * Define the number engine messages will start at. For GUI platforms, the starting
 * number is WM_USER to allow the engine CallBack to be integrated with the GUI
 * CallBack. 
 */

#if defined WINDOWS
#define AV_MSGSTART WM_USER
#else
#define AV_MSGSTART 0
#endif

/*
 * AV_MESSAGE lists the types of messages that can be issued to the engines
 * callback function during a scan. Some AV_MESSAGE types are a mirror for
 * an AV_ERROR type. The advantage of AV_MESSAGE types is that they can
 * contain attributes. See API user manual for more details.
 */

typedef WORD AV_MESSAGE;
#define AVM_COMPONENTFAILURE AV_MSGSTART + 1    /* Serious error. AV_PARAM2 points to error message. */
#define AVM_BADPARAMETER AV_MSGSTART + 2        /* See AV_ERROR. AV_PARAM1 contains index to bad parameter.  */
#define AVM_QUERYDENYSCAN AV_MSGSTART + 7       /* Should engine continue to scan? Return TRUE to stop, FALSE o/w. */
#define AVM_QUERYDENYREPAIR AV_MSGSTART + 8     /* Should engine continue to repair?. Return TRUE to stop, FALSE o/w. */
#define AVM_QUERYTERMINATE AV_MSGSTART + 9      /* Should engine terminate? Callback returns TRUE to stop, FALSE o/w. */
#define AVM_DATABASEPASS AV_MSGSTART + 11       /* Number of passes reading db. AV_PARAM2 contains pass number. */
#define AVM_OBJECTPASS AV_MSGSTART + 12         /* Number of passes scanning object (after repair). AV_PARAM2 contains pass number. */
/* AV_MSGSTART + 13                             RESERVED */
#define AVM_SLICE AV_MSGSTART + 14              /* Perform a time-slice. */
/* AV_MSGSTART + 15                             RESERVED */
/* AV_MSGSTART + 16                             RESERVED */
  
#define AVM_OBJECTNAME AV_MSGSTART + 17         /* Object about to be scanned. AV_PARAM2 contains name. */
#define AVM_OBJECTSIZE AV_MSGSTART + 18         /* AV_PARAM2 contains size of object about to be scanned.  */
#define AVM_OBJECTOK AV_MSGSTART + 19           /* Object scanned and is ok. */
#define AVM_OBJECTNOTSCANNED AV_MSGSTART + 20   /* Unable to scan. AV_PARAM2 is member of AV_SCANERROR. */
#define AVM_OBJECTINFECTED AV_MSGSTART + 21     /* Object is infected. AV_PARAM2 points to AV_INFECTION struct. */
#define AVM_OBJECTNOTREPAIRED AV_MSGSTART + 22  /* Unable to repair. AV_PARAM2 is member of AV_SCANERROR. */
#define AVM_OBJECTREPAIRED AV_MSGSTART + 23     /* Object repaired. AV_PARAM2 points to AV_INFECTION struct. */
#define AVM_VIRUSNAME AV_MSGSTART + 24          /* Driver name. AV_PARAM1 is AV_DRIVERFORMATTYPE, AV_PARAM2 is virus name. */
#define AVM_OBJECTCLOSED AV_MSGSTART + 25       /* Scan Engine has finished with (and closed) the file object */
#define AVM_IOREQUEST AV_MSGSTART + 26          /* Engine making an IO request */
#define AVM_CONTAINSMACROS AV_MSGSTART + 27     /* Report that file contains macros */
#define AVM_MEMSCANPROGRESS AV_MSGSTART + 28    /* Memory Scan Progress (AV_PARAM2 contains Percentage)   */
/* AV_MSGSTART + 29                             RESERVED */
#define AVM_FNREQUEST AV_MSGSTART + 30          /* Engine making an External Fn Request */
/* AV_MSGSTART + 31                             RESERVED */
#define AVM_QUERYQUITSCANNING AV_MSGSTART + 32  /* Do we want to quit mid-file?   */
#define AVM_ALLMACROSDELETED AV_MSGSTART + 33   /* The result of /DAM */
/* AV_MSGSTART + 34                             RESERVED */
/* AV_MSGSTART + 35                             RESERVED */
#define AVM_OBJECTNAMERAW AV_MSGSTART + 36      /* The object name exactly as it appears in an archive */
#define AVM_OBJECTSTART AV_MSGSTART + 37        /* Indicates the start of an object. This will be matched with an AVM_OBJECTCLOSED */
#define AVM_CONTAINERSTART AV_MSGSTART + 38     /* Indicates the start of a container. (either nested archive or directory) */
#define AVM_CONTAINERCLOSED AV_MSGSTART + 39    /* Indicates the end of a container. (either nested archive or directory) */
#define AVM_OBJECTSUMMARY AV_MSGSTART + 40    /* Indicates that a nested object was deemed to be infected according to the current scan settings. */
#define AVM_INSTANCEINFO AV_MSGSTART + 41
#define AVM_REPAIRNOTIFY AV_MSGSTART + 42       /* Notification of intention to modify/edit object AV_PARAM1 is AV_NOTIFY_OBJECT. AV_PARAM2 points to AV_NOTIFICATION struct. */
/* DAT Updating messages */
#define AVM_DAT_VERSION AV_MSGSTART + 43        /* Indicates the version of the DAT being updated */
#define AVM_UPDATE_OK  AV_MSGSTART + 44         /* The DAT update was applied ok */
#define AVM_UPDATE_ERROR  AV_MSGSTART + 45      /* Reports an error that has occured during DAT updating */
#define AVM_QUERYUPDATEDENY  AV_MSGSTART + 46   /* Should the engine continue to apply DAT updates? */
#define AVM_ENGINECOMPONENT AV_MSGSTART + 47   /* Engine reports one of its components */
/* Package Scanning messages */
#define AVM_ADDTOPACKAGETABLE AV_MSGSTART + 48  /* Request to add item to package */
#define AVM_PACKAGEITEMSTART AV_MSGSTART + 49   /* A package item is about to be operated on. (AV_PARAM2 is item ID.) */
#define AVM_PACKAGEITEMCLOSED AV_MSGSTART + 50  /* Scan Engine has finished with (and closed) the package item. (AV_PARAM2 is item ID.) */
#define AVM_PACKAGESTATUS AV_MSGSTART + 51      /* Report the cleaning status of the package. (AV_PARAM2 is AV_ACTIONTYPE.)*/
/* AV_MSGSTART + 52                             RESERVED */
/* AV_MSGSTART + 53 to 152                      RESERVED */
/* AV_MSGSTART + 153                            RESERVED */
/* AV_MSGSTART + 154                            RESERVED */
/* AV_MSGSTART + 155                            RESERVED */
/* AV_MSGSTART + 156                            RESERVED */
/* AV_MSGSTART + 157                            RESERVED */
/* AV_MSGSTART + 158                            RESERVED */
/* AV_MSGSTART + 159                            RESERVED */

/*
 * AV_SCANNERROR lists the type of errors the engine can report if it is unable
 * or unwilling to scan an object.
 */

typedef WORD AV_SCANERROR;
#define AVS_NOERROR 0           /* No scanning problems encountered */
#define AVS_NOTEXECUTABLE 1     /* File does not have an extension recognised as executable */
#define AVS_LOCKED 2            /* Data could not be read from/written to the object */
#define AVS_ENCRYPTED 3         /* File is encrypted and scanner is unable to decrypt */
#define AVS_OUTOFMEMORY 4       /* File could be scanned if more memory was available */
#define AVS_DRIVERFAILURE 5     /* The database failed (database possibly corrupt) */
#define AVS_COMPONENTFAILURE 6  /* Critical engine failure */
#define AVS_LOADFAILURE 7       /* Loading support DLL failed */
#define AVS_NOREADACCESS 8      /* Permission denied to open the file */
#define AVS_CIRCULARLINK 9      /* The file is a link to itself */
#define AVS_BCSFILE 10          /* The file is a Block/Char/FIFO special file */
#define AVS_OBJECTINCORRECT 11  /* Not the expected object (i.e. a directory when expected a file) */
#define AVS_CALLERDENIED 12     /* Caller denied engine access to either scan or repair */
#define AVS_ZEROLENGTH 13       /* Object is zero length and is therefore unscannable (assumed clean) */
#define AVS_CORRUPTED 14        /* File is probably corrupted */
#define AVS_DELDENIED 15        /* file deletion denied by the engine (compressed & office files) */
#define AVS_RENDENIED 16        /* File rename denied by the engine (compressed & office files) */
#define AVS_NOREPAIRINFO 17     /* No repair section in driver. */
#define AVS_COMPRESSCORRUPTED 18/* Compressed file is corrupted */
#define AVS_SYMBOLICLINK 19     /* The file/directory is a symbolic link. */
#define AVS_DELETEREBOOT 20     /* The file will be deleted on reboot */
#define AVS_PROCESSNOTRUNNING 21/* The process does not exist */
#define AVS_EXCLUDED 22         /* The object has not been scanned due to it being excluded by AVP_EXCLUDE */
#define AVS_CLEANLOOPLIMIT 23   /* The object has been attempted to be cleaned upto the maximum limit defined. It is still infected. */
#define AVS_NESTINGLIMIT 24     /* The object was not scanned because the nesting limit has been hit */
#define AVS_NOTIDENTIFIED 25    /* The object cannot be cleaned because the detect_type was not AVD_IDENTIFIEDVIRUS */
#define AVS_UNSUPPORTED 26      /* The object is not supported. */
#define AVS_OFFLINEFILE 27      /* The object is offline. */

/* AV_DETECTTYPE lists what we know about the virus we have found. */
typedef WORD AV_DETECTTYPE;
#define AVD_NOVIRUS 0           /* Nothing found. */
#define AVD_IDENTIFIEDVIRUS 1   /* Virus positively identified. */
#define AVD_LIKEKNOWNVIRUS 2    /* Virus is like one known about. */
#define AVD_SENDSPECVIRUS 3     /* As above, but we'd like a specimen. */
#define AVD_NEWVIRUS 4          /* Virus found by heuristics scanner. */
#define AVD_ERROR 5             /* Engine failure. */

/* AV_VIRUSTYPE is the class of virus. */
typedef WORD AV_VIRUSTYPE;
#define AVT_VIRUS 0     /* The file has a virus */
#define AVT_TROJAN 1    /* The file is a trojan */
/* 2                    RESERVED */
/* 3                    RESERVED */
#define AVT_COMP 4      /* Compressed file */
#define AVT_JOKE 5      /* Joke file */
#define AVT_TEST 6      /* Test file */
/* 7                    RESERVED */
#define AVT_WANNABEE 8  /* Virus author tried but failed to write a virus */
#define AVT_KILLED 9    /* File has been overwritten by a virus */
#define AVT_APP 10      /* Commercial Application */
/* 11                   RESERVED */
#define AVT_PUO 12      /* Potentially unwanted object */
#define AVT_PACKAGE 13  /* Potentially unwanted software package */
/* 14                   RESERVED */
/* 15                   RESERVED */
/* 16                   RESERVED */

/* AV_ACTIONTYPE lists the actions that have been performed by the scanner on */
/* the file. */
typedef WORD AV_ACTIONTYPE;
#define AVA_NOACTION 0      /* No action was taken on the file. */
#define AVA_ACTIONFAILED 1  /* Requested action failed. */
#define AVA_REPAIRED 2      /* The file was repaired, and the virus removed. */
#define AVA_RENAMED 3       /* The file was renamed. */
#define AVA_DELETED 4       /* The file was deleted. */
#define AVA_MOVED 5         /* The file was moved to a new location. */
#define AVA_PARTIALLYCLEANED 6 /* The package was partially cleaned. */

/* AV_OBJECTTYPE lists the objects currently handled by the scanner. */
typedef WORD AV_OBJECTTYPE;
#define AVO_MEMORY 1
#define AVO_BOOTSECTOR 2
#define AVO_PARTITIONSECTOR 3
#define AVO_DIRECTORY 4
#define AVO_FILE 5
#define AVO_MACRO 6
#define AVO_ARCHIVE 7
#define AVO_COMPRESSEDFILE 8
#define AVO_ARCHIVEFILE 9
#define AVO_PROCESS 10
#define AVO_PROCESSFILE 11
#define AVO_MACROCONTAINER 12
#define AVO_COOKIE 13
#define AVO_REGISTRY32 14
#define AVO_REGISTRY64 15
#define AVO_PACKAGE 16
/* 17                       RESERVED */

/* AV_DRIVERFAILTYPE lists various ways in which loading the driver files */
/* could fail. */
typedef WORD AV_DRIVERFAILTYPE;
#define AVF_NOFAILURE 0  
#define AVF_VERSIONFAIL 1           /* Engine does not handle this revision of the driver. */
#define AVF_CHECKSUMFAIL 2          /* Driver failed its checksum. */
#define AVF_DIDNOTEXIST 3           /* Specified driver did not exist. */
#define AVF_OUTOFMEMORY 4           /* Database could not be read due to insufficient memory */
#define AVF_INCORRECTFILECOUNT 5    /* The number of files in the DAT set was not correct */
#define AVF_INVALIDFORMAT 6         /* The DAT file was not of a recognised format */
#define AVF_DUPLICATEFILETYPE 7     /* The DAT file is of the same type as another file in the set. */
#define AVF_UNRECOGNISEDDATFILE 8   /* The type of the DAT file is not known to this version of the engine. */
#define AVF_INCORRECTDATSETTYPE 9   /* The type of the DAT set is not consistent with the API parameter.  */
#define AVF_MISMATCHEDVERSION 10    /* The versions of the DAT files in the same set are not the same as each other. */
#define AVF_EXPIRED 11              /* The DAT file has expired. */

/* AV_UPDATERROR lists various ways in which DAT updating could fail */
typedef WORD AV_UPDATEERROR;
#define AVUE_NOERROR 0
#define AVUE_INVALID_MICROFORMAT 1  /* Micro Incremental DAT format not recognised */
#define AVUE_CORRUPT_MICRO 2        /* Micro Incremental DAT appears to be corrupt */
#define AVUE_WRONG_MICRO_VERSION 3  /* Micro Incremental DAT does not apply to the DAT being updated */
#define AVUE_MICRO_NOT_IN_ORDER 4   /* Micro Incremental DATs are not provided in the correct sequence */
#define AVUE_WRONG_MICRO_TYPE_FOR_DATSET 5 /* Micro Incremental DAT does not apply to the DAT set being updated */
#define AVUE_OUTOFMEMORY 6          /* An allocation operation failed. */
#define AVUE_WRITEDENIED 7          /* A write on the updated DAT failed */
#define AVUE_NOREADACCESS 8         /* Read access was denied */
#define AVUE_CALLERDENIED 9         /* Caller responded true to AVM_QUERYUPDATEDENY */
       
/* AV_DRIVERFORMATTYPE lists the type of dat files the API supports. */
typedef WORD AV_DRIVERFORMATTYPE;
#define AVV_FIND 0          /* SCAN.DAT */
#define AVV_NAMES 1         /* NAMES.DAT */
#define AVV_REPAIR 2        /* CLEAN.DAT */
#define AVV_EXTRA 3         /* (default) EXTRA.DAT */
#define AVV_INDEX 4         /* (not used currently) */
#define AVV_RUNTIME 5       /* The runtime DAT set (AV_DATSETTYPE_RUNTIME) */

/* For displaying string literals. */
typedef WORD AV_LITERALTYPE;
#define AVL_LITERAL 0
#define AVL_NUMBER 1

/* AV_SUPPORTLEVEL lists the support levels read in from the DATs */
typedef WORD AV_SUPPORTLEVEL;
#define AVU_FULLYSUPPORTED 0        /* All's well - fully supported */
#define AVU_INENDOFLIFETIME 1       /* Will not be supported for much longer - the end is nigh */
#define AVU_UNSUPPORTED 2           /* No support available */
#define AVU_LIFEEXPIRED 3           /* Product has been killed */
#define AVU_NOTAPPLICABLE 0xFFFE    /* Internal use - will never be returned by the API */
#define AVU_ERROR 0xFFFF            /* Internal use - will never be returned by the API */

/* AV_CACHELEVEL lists the supported levels of caching per read for offline files on Win32 */
typedef WORD AV_CACHELEVEL;

#define AVC_128KB      0    /* use 128kB reads */
#define AVC_256KB      1    /* use 256kB reads */
#define AVC_512KB      2    /* use 512kB reads */
#define AVC_1MB        3    /* use 1MB reads */
#define AVC_2MB        4    /* use 2MB reads */
#define AVC_MINIMUM    AVC_128KB  /* minimum cache size per read allowed - currently 128kB */
#define AVC_MAXIMUM    AVC_2MB    /* maximum cache size per read allowed - currently 2MB */


/*
 * AV_VFILETYPE lists the IO requests that can come with the AVIORQ_ISA
 * request. These are only relevant for sector scanning.
 */
typedef WORD AV_VFILETYPE;
#define AVI_USERGFS 0           /* All UserGFS implementations have this. */
#define AVI_FLOPPYDISKDEVICE 40 /* Low level floppy access modelled as file. */
#define AVI_HARDDISKDEVICE 41   /* Low level hard disk access */
#define AVI_DOSDEVICE 42        /* Low level access via DOS. */
#define AVI_BIOSDEVICE 43       /* Low level access via the BIOS. */
#define AVI_525FLOPPYDISK 44    /* 5.25" floppy disk. */
#define AVI_35FLOPPYDISK 45     /* 3.5" floppy disk */

/*
 * AV_EXTLISTTYPE lists the different combinations of extension list
 * available to be retrieved through the AVRetrieveExtensionList function.
 * This function is available only in the V2 interface.
 */
typedef WORD AV_EXTLISTTYPE;
#define AV_EXTLIST_ALL 1            /* All extension lists merged together with duplicates removed */
#define AV_EXTLIST_EXE 2            /* The exe extension list */
#define AV_EXTLIST_MACRO 3          /* The macro extension list */
#define AV_EXTLIST_COMPRESSEDEXE 4  /* The compressed exe extension list */
#define AV_EXTLIST_ARCHIVE 5        /* The archive extension list */

typedef WORD AV_OBJECTSUMMARY;
#define AV_SUMMARY_OBJECTOK 0
#define AV_SUMMARY_NOTSCANNEDERROR 1
#define AV_SUMMARY_NOTSCANNEDSETTINGS 2
#define AV_SUMMARY_INFECTED 3

typedef WORD AV_INFOTYPE;
#define AVINFO_VIRUSNAME 1
#define AVINFO_EXTENSIONLIST 2
#define AVINFO_REGTARGETS 3
#define AVINFO_POINTPRODUCT_DATA 4
/* 5                                RESERVED */

/* Types used with the registry target table */
typedef WORD AVR_TYPE;
#define AVR_KEY	0               /* Pass sub-keys to the engine */
#define AVR_VALUE	1           /* Pass values to the engine */

/* Types and values used with the AV_OBJECT structure. */
typedef WORD AVO_TYPE;
#define AVOT_UNSPECIFIED 0      /* No type specified */
#define AVOT_DOSMEMORY 1        /* Scan DOS memory */
#define AVOT_BOOTSECTOR 2       /* Scan a boot sector */
#define AVOT_PARTITIONSECTOR 3  /* Scan a partition sector */
#define AVOT_FILE 4             /* Scan a file */
#define AVOT_DIRECTORY 5        /* Scan a directory */
#define AVOT_PROCESS 6          /* Scan a process or processes */
#define AVOT_REGISTRY 7			/* Scan a registry entry */
#define AVOT_COOKIE 8           /* Scan a cookie file */
#define AVOT_PACKAGE 9          /* Scan a package */
/* 10                              RESERVED */
#define AVOT_MEMSCAN 11         /* Scan Memory */

typedef WORD AVO_SUBTYPE;
#define AVOS_UNSPECIFIED 0      /* No subtype specified */
#define AVOS_DOSPATH 1          /* Use engine IO. The attribute contains the path */
#define AVOS_USERFILETABLE 2    /* Use deferred IO. The attribure contains the handle. */
#define AVOS_BIOSDEVICE 3       /* Scan a bios device. The attribute contains the device. */
#define AVOS_DOSDEVICE 4        /* Scan a dos device. The attribute contains the drive letter. */
#define AVOS_PID 5              /* Scan a single process. The attribute contains the PID. */
#define AVOS_ALLPROCESSES 6     /* Scan all processes. The attribute is ignorred. */

/* The type for a reference to a DAT set as returned in AV_INITRESULT. */
typedef DWORD AV_DATSETREFERENCE;

/* The type of IO to use when reading DAT files. */
typedef WORD AV_READTYPE;
#define AV_READTYPE_DIRECT 0
#define AV_READTYPE_DEFERRED 1

/* Type the engine uses to indicate the corresponding dat set for the 
 * status data returned.
 */
typedef WORD AV_DATSETTYPE;
#define AV_DATSETTYPE_OLYMPUS 1
#define AV_DATSETTYPE_AV 2
#define AV_DATSETTYPE_PUP 3
#define AV_DATSETTYPE_EXTRA 4
#define AV_DATSETTYPE_TROJAN 5
#define AV_DATSETTYPE_MAC 6 /* Deprecated. The MacScanner has been removed. */
/* 7                       RESERVED */
/* 8                       RESERVED */
#define AV_DATSETTYPE_RUNTIME 9


/* Define standard library return type. For Windows this must be FAR PASCAL EXPORT. */
#if   defined WIN_32
#define DllImport   __declspec( dllimport )
#define DllExport   __declspec( dllexport )
#define LIBFUNC CALLBACK
#define EXPLIBFUNC DllExport LIBFUNC
#else
#define LIBFUNC
#define EXPLIBFUNC LIBFUNC
#endif

/* Define CallBack types to be compatible with normal O/S Callbacks.... */
#if defined WINDOWS
typedef LRESULT AV_LIBRET;
typedef WPARAM AV_PARAM1;
typedef LPARAM AV_PARAM2_V1;
#else
typedef WORD AV_LIBRET;
typedef WORD AV_PARAM1;
#if   defined UNIX && defined _64BIT_
typedef size_t AV_PARAM2_V1;
#else
typedef DWORD AV_PARAM2_V1;
#endif
#endif

#if defined AVENGINEAPI_V2 || defined AV_NO_GENERIC_TYPES
/* Removed this union from the V1 API as it does not conform
 * to the C89 standard.
 */
typedef union
{
    DWORD    dwValue;
    QWORD    qwValue;
    void*    pValue;
} AV_PARAM2_V2;
#endif

typedef struct
{
    size_t   structure_size;    /* Size of this structure */
    size_t   data_size;         /* size of the extracted data */
    BYTE   * data;              /* data itself */
} AV_USER_EXTRACTED_DATA;

#if defined AV_NO_GENERIC_TYPES
    typedef void AV_PARAM2;
#else
    #if defined AVENGINEAPI_V2
        typedef  AV_PARAM2_V2 AV_PARAM2;
    #else
        typedef  AV_PARAM2_V1 AV_PARAM2;
#endif
#endif

typedef void* IO_HANDLE;

/* Type of scanning engine callback function. */
typedef AV_LIBRET (LIBFUNC *AV_CALLBACKTYPE_V1)(HSCANNER, AV_MESSAGE, AV_PARAM1, AV_PARAM2_V1);

#if defined AVENGINEAPI_V2 || defined AV_NO_GENERIC_TYPES
/* Removed this type from the V1 API as it uses a type (AV_PARAM2_V2)
 * that does not conform to the C89 standard.
 */
typedef AV_LIBRET (LIBFUNC *AV_CALLBACKTYPE_V2)(HSCANNER, AV_MESSAGE, AV_PARAM1, AV_PARAM2_V2);
#endif

#if defined AV_NO_GENERIC_TYPES
    typedef void AV_CALLBACKTYPE;
#else
    #if defined AVENGINEAPI_V2
        typedef  AV_CALLBACKTYPE_V2 AV_CALLBACKTYPE;
    #else
        typedef  AV_CALLBACKTYPE_V1 AV_CALLBACKTYPE;
    #endif
#endif



/*************************
 *                       *
 * Structure definitions.*
 *                       *
 *************************/

typedef struct
{
	size_t  size;
	DWORD  *data;  /* Points  to an array of DWORD at least size long*/
} AVO_CONTEXT;


typedef struct
{
    WORD structure_size;
    
    AVO_TYPE type;
    AVO_SUBTYPE subtype;
    AVO_CONTEXT * pcontext;

    void *pAttribute;
    DWORD size;
} AV_OBJECT;

/* The AV_INFECTION structure contains information about a virus that has
 * been found. This information will be received in the callback function.
 */
typedef struct
{
    WORD structure_size;            /* Size of subsequent structure. Set by caller. */
    AV_DETECTTYPE detect_type;      /* What we know about the virus detected (i.e. identified, send spec etc) */
    AV_VIRUSTYPE virus_type;        /* Type of virus. */
    AV_ACTIONTYPE action_taken;     /* Action taken by repairer. */
    char virus_name[MAXVIRUSNAME_V1];  /* Name of virus. */
    #if	!defined	MacOS
    BOOL bRepairable;				/* only valid if AVP_CHECKREPAIRABILITY was set */
    #endif

} AV_INFECTION_V1;

typedef struct
{
    WORD structure_size;             /* Size of subsequent structure. Set by caller. */
    AV_DATSETREFERENCE dat_reference;/* The reference to the DAT set where this detection was generated */
    AV_DETECTTYPE detect_type;       /* What we know about the virus detected (i.e. identified, send spec etc) */
    AV_VIRUSTYPE virus_type;         /* Type of virus. */
    AV_ACTIONTYPE action_taken;      /* Action taken by repairer. */
    WORD nesting_deleted;            /* The nesting level at which the object was deleted. */
    char *virus_name;                /* Name of virus. */
    BOOL repairable;			 	 /* only valid if AVP_CHECKREPAIRABILITY was set */
} AV_INFECTION_V2;

#if defined AV_NO_GENERIC_TYPES
typedef void AV_INFECTION;
#else
#if defined AVENGINEAPI_V2
typedef AV_INFECTION_V2 AV_INFECTION;
#else
typedef AV_INFECTION_V1 AV_INFECTION;
#endif
#endif

/* The AV_SCANRESULT structure contains statistics relevant to an object
 * scan. This information is returned by scanning functions once they
 * have completed.
 * NOTE: This structure must be initialised before being passed to the
 * engine - the engine will not zero or initialise any member !
 */
typedef struct
{
    WORD structure_size;
    AV_OBJECTTYPE object_type;          /* See AV_OBJECTTYPE. */

    /* Objects clean.... */
    DWORD nobjects_clean;               /* Objects definitely clean. */

    /* Objects not scanned for some reasons.... */
    DWORD nobjects_notscanned;          /* Objects deliberately not scanned. */
    DWORD nobjects_locked;              /* Objects unable to open. */
    DWORD nobjects_encrypted;           /* Objects encrypted. */
    DWORD nobjects_corrupted;           /* Objects corrupted. */
    DWORD nobjects_fpermissiondenied;   /* Files with incorrect permissions */
    DWORD nobjects_dpermissiondenied;   /* Directories with incorrect permissions */
    DWORD nobjects_bcsfile;             /* Objects which are UNIX special files */
    DWORD nobjects_callerdenied;        /* Objects which caller did not wish us to scan */

    /* Objects infected.... */
    DWORD nobjects_infected;            /* Objects infected. */
    DWORD nobjects_trojan;              /* Objects that are trojans. */
    DWORD nobjects_joke;                /* Objects infected with joke virus. */
    DWORD nobjects_test;                /* Objects that are test files. */
    DWORD nobjects_compressed;          /* Objects that are compressed. */

    /* Objects repair status.... */
    DWORD nobjects_repaired;            /* Objects fully repaired (virus removed) */
    DWORD nobjects_renamed;             /* Objects renamed (where applicable) */
    DWORD nobjects_deleted;             /* Objects permanently deleted (where applicable) */
    DWORD nobjects_moved;               /* Objects moved somewhere (where applicable) */

    /* Amount of data scanned */
    DWORD data_scanned;
    
    /* 4100 additions.... */
    DWORD nobjects_application;         /* Objects that are commercial applications. */

    /* 4150 additions.... */
    DWORD nobjects_needreboot;          /* Objects that need reboot to complete the repair */

} AV_SCANRESULT_V1;

typedef struct
{
    WORD structure_size;
} AV_SCANRESULT_V2;

#if defined AV_NO_GENERIC_TYPES
typedef void AV_SCANRESULT;
#else
#if defined AVENGINEAPI_V2
typedef AV_SCANRESULT_V2 AV_SCANRESULT;
#else
typedef AV_SCANRESULT_V1 AV_SCANRESULT;
#endif
#endif

/* Structure to pass the files in a DAT set to the engine. */
typedef struct
{
    WORD structure_size;
    AV_READTYPE read_type;              /* The method of reading the DATs - direct or deferred. */
    WORD datfile_count;                 /* The number of DAT files in the set. */
    union
    {
        const char **datfile_names;     /* The DAT file names. */
        IO_HANDLE *datfile_handles;     /* The IO handles for the DAT files. */
    } datfiles;
} AV_DATSETFILES;

/* The AV_DRIVERSTATUS structure contains information about how a driver
 * might have failed its (many!) integrity checks. It contains the
 * name of the driver and how it has failed
 */
typedef struct
{
    WORD structure_size;
    char driver_name[MAXPATH];          /* name of driver. */
    WORD driver_date;                   /* date of driver. */
    WORD driver_checksum;               /* checksum of driver. */
    WORD nviruses;                      /* Number of viruses detected by driver. */
    WORD nvariants;                     /* Number of variants detected by driver. */
    AV_DRIVERFORMATTYPE driver_format;  /* type of driver. */
    AV_DRIVERFAILTYPE failure_type;     /* type of failure. */
} AV_DRIVERSTATUS_V1;


/* The structure indicating the information/status
 * about a particular DAT file
 */
typedef struct
{
    WORD structure_size;
    AV_DRIVERFORMATTYPE type;           /* The type of the DAT file e.g. AVV_FIND */
    char *name;                         /* Name of the DAT file. */
    WORD date;                          /* Date of the DAT file */
    AV_DRIVERFAILTYPE status;           /* Type of failure */
} AV_DATFILESTATUS;

/* The structure indicating the status of a DAT set. */
typedef struct
{
    WORD structure_size;
    AV_DATSETREFERENCE reference;       /* The reference for the DAT set. */
    AV_DATSETTYPE type;                 /* Type of the DAT set e.g. AV_DATSETTYPE_PUP */
    DWORD major_version;                /* The major version */
    DWORD minor_version;                /* The minor version */
    DWORD nviruses;                     /* Number of detections in the DAT set */
    DWORD nvariants;                    /* Number of variant detections in the DAT set. */
    WORD datfile_count;                 /* Number of files in the set. */
    AV_DATFILESTATUS **datfiles_info;   /* Status information about each of the files. */
    AV_DRIVERFAILTYPE status;           /* Type of failure */
} AV_DATSETSTATUS;


/*
 * Number of DAT files the engine uses (currently SCAN.DAT, NAMES.DAT,
 * CLEAN.DAT, EXTRA.DAT). In the 5000 API, this number may change. There
 * should be AVV_ values that range from 0 to MAX_DRIVERS-1
 */
#define MAX_DRIVERS_V1 4

#if !defined AV_NO_GENERIC_TYPES
#if !defined AVENGINEAPI_V2
#define MAX_DRIVERS MAX_DRIVERS_V1
#endif
#endif

/* max length of NAI engine version string */
#define NAI_ENGINE_VER_STR_LEN_V1  32

#if !defined AV_NO_GENERIC_TYPES
#if !defined AVENGINEAPI_V2
#define NAI_ENGINE_VER_STR_LEN NAI_ENGINE_VER_STR_LEN_V1
#endif
#endif

/* Structure used to define a list of file extensions for the engine to check. */
#define AV_MAXEXT_LEN	4
#define NUM_FILE_TYPES 4
typedef struct
{ 
    char extension[AV_MAXEXT_LEN];
    DWORD mask;
} AV_EXTENSIONTYPE;

/* Two useful masks - match all characters in extensions, and match all
 * extensions.
 */
#define MATCH_ALL_CHARS 0xffffffff
#define MATCH_ALL_EXTENSIONS 0

/* Structure defining a list of extensions to check. */
typedef struct
{
    WORD nextensions;
    AV_EXTENSIONTYPE* extensions;
} AV_EXTENSIONLIST;

/* Structure used for returning the extension lists from the engine. */
typedef struct
{
    WORD structure_size;
    AV_EXTLISTTYPE list_type;
    AV_EXTENSIONLIST list;
} AV_EXTENSIONINFO;
      

/* The AV_INITRESULT structure contains information about the engine and 
 * driver that have been instantiated with a call to AVInitialise.
 * Crucially, it contains a handle to the engine which must be used in
 * all subsequent calls.
 */
typedef struct
{
    WORD    structure_size;
    HENGINE engine_handle;        /* Unique handle referring to an instance of the engine. */
    WORD    nviruses;             /* Number of viruses detected by driver. */
    DWORD   internal_revision;    /* Engine internal revision. */
    DWORD   signature;            /* Vendor specific engine signature. */
    AV_DRIVERSTATUS_V1 driver_status[MAX_DRIVERS_V1]; /* Status of all drivers specified. */

#if !defined MacOS
    
    DWORD   nai_ver;              /* NAI version number for drivers ie; V4001 */
    char    nai_engine_ver[NAI_ENGINE_VER_STR_LEN_V1 + 1]; /* NAI engine version number. eg 4.0.1 */

#endif

	DWORD dwnviruses;		/* real number of viruses, use this in preference to the nviruses number above */
							/* thats just been kept for legacy applications	 */

    /* Access to the default file extension lists.
     * Use these sizes to allocate for AV_EXTENSIONLISTS*
     * before the call to RetrieveExtensionLists().
    */
    DWORD exe_ext_list_size;            /* Extensions we scan for exes, coms etc. */
    DWORD archive_ext_list_size;        /* Try and instantiate archives from these - ZIP, ARJ etc. */
    DWORD compressedexe_ext_list_size;  /* PKLite etc. */
    DWORD macro_ext_list_size;          /* Compound documents (OLE). */

    DWORD single_ext_list_size;         /* And the whole lot. */


} AV_INITRESULT_V1;

typedef struct
{
    WORD    structure_size;
    HENGINE engine_handle;      /* Unique handle referring to an instance of the engine. */

    DWORD major_version;        /* Major version of the engine. */
    DWORD minor_version;        /* Minor version of the engine. */
    DWORD internal_revision;    /* Engine internal revision. */

    WORD datset_count;          /* Number of entries in datset_status*/
    const AV_DATSETSTATUS **datset_info;
                                /* Status of all DAT sets specified. */
} AV_INITRESULT_V2;

#if defined AV_NO_GENERIC_TYPES
typedef void AV_INITRESULT;
#else
#if defined AVENGINEAPI_V2
typedef AV_INITRESULT_V2 AV_INITRESULT;
#else
typedef AV_INITRESULT_V1 AV_INITRESULT;
#endif
#endif

/* Macros to break down the date into day/month/year */
#if defined AVENGINEAPI_V2
#define EXTRACT_DRIVER_DAY(a)   (a->date & 0x1f)
#define EXTRACT_DRIVER_MONTH(a) ((a->date >> 5) & 0xf)
#define EXTRACT_DRIVER_YEAR(a)  ((a->date >> 9) + 1980)
#else
#define EXTRACT_DRIVER_DAY(a)   (a.driver_date & 0x1f)
#define EXTRACT_DRIVER_MONTH(a) ((a.driver_date >> 5) & 0xf)
#define EXTRACT_DRIVER_YEAR(a)  ((a.driver_date >> 9) + 1980)
#endif

/* Macros to break down the version into major and minor revision */
#define EXTRACT_IVN_MAJOR(a)    (a.internal_revision >> 16)
#define EXTRACT_IVN_MINOR(a)    (a.internal_revision & 0xffff )

/* The AV_SINGLEPARAMETER and AV_PARAMETERS structures make up the parameter
 * passing method to the Olympus engine.
 */
typedef struct
{
    WORD structure_size;
    AV_PARAMETERCODE parameter_code;    /* Parameter code number.  */
    DWORD attributes_size;              /* Size of following attributes. */
    void *attributes;                   /* Pointer to attributes. Type of attributes inferred from parameter_code. */
} AV_SINGLEPARAMETER;

typedef struct
{
    WORD structure_size;
    WORD nparameters;               /* Number of parameters. */
    AV_SINGLEPARAMETER *parameters; /* Pointer to memory storing parameter table. */
} AV_PARAMETERS;

/* Engine handles represented by the AV_ENGINEHANDLE structure */
typedef struct
{
    HENGINE engine_handle;          /* Handle to engine */
    void* user_data;                /* User defined data */
} AV_SCANNERHANDLE;

/* Extract engine handle from AV_ENGINEHANDLE */
#define EXTRACT_ENGINE_HANDLE(a) (((AV_SCANNERHANDLE*)(a))->engine_handle)

/* Extract user defined data from AV_ENGINEHANDLE */
#define EXTRACT_USER_DATA(a) (((AV_SCANNERHANDLE*)(a))->user_data)


/* The structure for use with AVP_EXCLUDEDATSET and AVP_USEDATSET to
 * list the DAT sets to either use or exclude.
 */
typedef struct
{
    WORD structure_size;
    WORD datset_count;
    AV_DATSETREFERENCE *references;
} AV_DATSETLIST;


/* Types of IO request that can be made (from AVM_IOREQUEST) */
typedef WORD AV_IOREQUESTTYPE;
#define AVIORQ_ISA  1
#define AVIORQ_FILENAME 2
#define AVIORQ_PATHNAME 3
#define AVIORQ_SIZE 4
#define AVIORQ_SIZECHS 5
#define AVIORQ_DATE 6
#define AVIORQ_OPENREAD 7
#define AVIORQ_OPENWRITE 8
#define AVIORQ_OPENCREATE 9
#define AVIORQ_CLOSE 10
#define AVIORQ_READ 11
#define AVIORQ_WRITE 12
#define AVIORQ_CHANGESIZE 13
#define AVIORQ_DELETE 14
#define AVIORQ_RENAME 15
#define AVIORQ_SEEKSTART 16
#define AVIORQ_SEEKCURRENT 17
#define AVIORQ_SEEKEND 18
#define AVIORQ_TELL 19
#define AVIORQ_TELLCHS 20
#define AVIORQ_GOTOCHS 21
#define AVIORQ_GOTO 22
#define AVIORQ_ENDOFFILE 23
#define AVIORQ_FILEEXTENSION 24
#define AVIORQ_MOVEFILE 25
#define AVIORQ_CHANGEFILE 26
#define AVIORQ_DELETEFILE 27
#define AVIORQ_FILEREQUEST 28
#define AVIORQ_FINISHFILE 29
#define AVIORQ_SECTORSIZE 30
#define AVIORQ_ALTERNATENAME 31
#define AVIORQ_WIN32LONGPATHNAME 32
#define AVIORQ_WIN32FILEATTRIBUTES 33
#define AVIORQ_SETWIN32FILEATTRIBUTES 34
#define AVIORQ_DELETEONREBOOT 35

/*
 * The different types of file the deferredIO will request to access.
 */
typedef WORD AV_IOFILETYPE;
#define AVIOTYPE_EXTRAFILE 1        /* Any extra regular file it may need to access */
#define AVIOTYPE_TMPFILE 2          /* A temporary file the engine may need */

/* The value field for the return value of the AVIORQ_OPENWRITE and
 * AVIORQ_OPENREAD requests should be one of these.
 */
#define AVIOFAIL_NOFAIL 0
#define AVIOFAIL_UNSPECIFIEDFAIL 1
#define AVIOFAIL_INUSE 2

/* Various data packet structures. */
typedef struct
{
    WORD c;
    WORD h;
    WORD s;
} AV_IOCHSPACKET;

typedef struct
{
    DWORD nbytes;
    BYTE* buffer;
} AV_IORWPACKET;

typedef struct
{
    char *name1;
    char *name2;
    DWORD value;
} AV_IOCOMPANIONREPAIR;

typedef struct
{
    AV_IOFILETYPE file_type;
    BOOL create_file;
    const char *filename;
} AV_IOFILEREQUEST;

/* AV_IOREQUEST structure is passed back to caller when engine wishes
 * to make an IO request.
 */
typedef struct
{
    WORD structure_size;
    AV_IOREQUESTTYPE io_request;
    IO_HANDLE io_handle;

    /* Different data packet types */
    union 
    {
        DWORD value;                    /* Integer value passed or returned */
        char* filename;                 /* FileName sent or requested */
        AV_IOCHSPACKET chs;             /* C:H:S specifier */
        AV_IORWPACKET rw;               /* Read/Write request */
        AV_IOCOMPANIONREPAIR crep;      /* Companion virus repair */
    } io_datapacket;

} AV_IOREQUEST_V1;

#if defined AVENGINEAPI_V2 || defined AV_NO_GENERIC_TYPES
/* Removed this structure from the V1 API as it does not conform
 * to the C89 standard.
 */
typedef struct
{
    WORD structure_size;
    AV_IOREQUESTTYPE io_request;
    IO_HANDLE io_handle;

    /* Different data packet types */
    union 
    {
        QWORD value;                    /* Integer value passed or returned */
        char* filename;                 /* FileName sent or requested */
        AV_IOCHSPACKET chs;             /* C:H:S specifier */
        AV_IORWPACKET rw;               /* Read/Write request */
        AV_IOCOMPANIONREPAIR crep;      /* Companion virus repair */
        AV_IOFILEREQUEST fileRequest;   /* The type of file requested */
    } io_datapacket;

} AV_IOREQUEST_V2;
#endif

#if defined AV_NO_GENERIC_TYPES
    typedef void AV_IOREQUEST;
#else
    #if defined AVENGINEAPI_V2
        typedef AV_IOREQUEST_V2 AV_IOREQUEST;
    #else
        typedef AV_IOREQUEST_V1 AV_IOREQUEST;
    #endif
#endif


#if !defined AVENGINEAPI_V2 && !defined AV_NO_GENERIC_TYPES
/* AV_FNREQUEST structure is passed back to caller when engine wishes
 * to make an external function request.
 */
typedef struct
{
    WORD structure_size;
	DWORD fn_handle;			/* the identifying data passed with the parameter */
    DWORD method;				/* the method to be used */
	WORD datalen;				/* some static data len for it */
	const BYTE *data;			/* some static data for it */
	IO_HANDLE io_handle;		/* the cookie for the gfs object */
	AV_CALLBACKTYPE_V1 callback;/* the callback to use the io_handle with */

} AV_FNREQUEST;
#endif


/* AV_ENDOFLIFEINFO structure is passed back to caller when a product wishes
 * to check whether the engine or product is out of date.
 */
typedef struct
{
    WORD structure_size;
	WORD product_id;	        /* product identifier */
    WORD locale;				/* locale identifier */
	WORD product_support_level;	/* support level of the product */
    WORD engine_support_level;  /* support level of the engine */
} AV_ENDOFLIFEINFO;


/* AV_RAWOBJECTNAME structure is passed back to the caller when the caller
 * uses the AVP_RAWOBJECTNAME parameter. It contains the name of the object
 * exactly as it appears in the archive.
 */

typedef struct
{
    size_t length;              /* The length of the raw name */
    BYTE *raw_name;             /* The raw name */
} AV_SINGLERAWOBJECTNAME;

typedef struct
{
    WORD structure_size;
    WORD nnames;
    AV_SINGLERAWOBJECTNAME *names;
} AV_RAWOBJECTNAME;


/* -----------------------------------------
 * Virus List structures and types
 * For V2 API only
 * -----------------------------------------
 */

typedef struct
{
    WORD structure_size;                /* structure size */
   
    AV_VIRUSTYPE virus_type;            /* virus type */

    char *virus_name;                   /* virus name */
    WORD nvariants;                     /* number of variants */
    char **variants;                    /* array of variant name (NULL terminated strings) */
} AV_VIRUSINFO;


/*
 * Engine incremental updating and hotfixing
 * types and constants
 * 
 */

typedef WORD AV_ENGINECOMPONENTTYPE;
#define AVEC_UPDATE 1
#define AVEC_HOTFIX 2

typedef WORD AV_ENGINECOMPONENTSTATUS;
#define AVECS_LOADED    1   /* component is loaded and used by the engine */
#define AVECS_CORRUPTED 2   /* digital signature of component is not matching engine's manifest */
#define AVECS_NOTFOUND  3   /* component is listed in manifest but is missing in the system */
#define AVECS_OBSOLETE  4   /* only for hotfixes - component is replaced by newer version */

typedef struct
{
	WORD structure_size;			  /* structure size in bytes */
	
	char* file_name;                  /* NULL-terminated string component file name */
	WORD major_ver;                   /* Major version of the component */
	WORD minor_ver;				      /* Minor version of the component */
	AV_ENGINECOMPONENTSTATUS status;  /* Component status */
} AV_ENGINECOMPONENT;
             
typedef struct
{
	WORD          structure_size; /* structure size */
	char*         path;           /* Path to treekwalk */
	DWORD         context;        /* Context to use for the scan */
	AVR_TYPE      type;           /* Treewalk for keys or values */
} AV_REGTARGET;


typedef struct
{
	WORD          structure_size; /* structure size */
	DWORD         nTargets;       /* Number of targets */
	AV_REGTARGET** regTargets;    /* Array of pointers to target structures */
} AV_REGTARGETTABLE;


/* AV_NOTIFY_OBJECT lists the objects for which notifications can be sent during repair */
typedef WORD AV_NOTIFY_OBJECT;
#define AVN_FILE              1 
#define AVN_REGISTRY_KEY_32   2
#define AVN_REGISTRY_VALUE_32 3
#define AVN_REGISTRY_KEY_64   4
#define AVN_REGISTRY_VALUE_64 5
#define AVN_PROCESS           6
#define AVN_DIRECTORY         7

/* AV_NOTIFY_ACTION lists the notifications the engine can  send to products during repair*/
typedef WORD AV_NOTIFY_ACTION;
#define AV_NOTIFY_OPEN       0        /* object about to be opened */
#define AV_NOTIFY_MODIFY     1        /* object about to be modified */
#define AV_NOTIFY_DELETE     2        /* object about to be deleted */
#define AV_NOTIFY_RENAME     3        /* object about to be renamed */
#define AV_NOTIFY_MOVE       4        /* object about to be moved */
#define AV_NOTIFY_ADD        5        /* object about to be added */
#define AV_NOTIFY_TERMINATE  6        /* object about to be terminated */
#define AV_NOTIFY_CLOSE      7        /* object about to be closed */  

typedef struct
{
    WORD             structure_size;   
    AV_NOTIFY_ACTION repair_action;   /* repair action about to be taken by engine */
    const char*      source_path;     /* source path of object */
    const char*      dest_path;       /* destination path of object */
} AV_NOTIFICATION;

/* 
 * Incremental DAT Updating 
 */

typedef struct
{
    WORD structure_size;
    AV_DATSETFILES *dat_set;        /* set of DATs to update */
    AV_DATSETFILES *updated_set;    /* set of updated DATs */
    AV_DATSETFILES *updates;        /* set of micro incremental DATs to apply */
} AV_UAPPLY;

/* Item identifiers for AVM_ADDTOPACKAGETABLE */
typedef WORD AV_ITEMID;
#define AV_ITEMID_NEW       (0xffff)
#define AV_ITEMID_LAST      (0xfffe)
#define AV_ITEMID_CURRENT   (0xfffd)

/* The type for a reference to a detection */
typedef DWORD AV_DETECTREF;

/* Data for each entry in the package table */
typedef struct
{
    WORD structure_size;
    DWORD package_id;               /* ID of the package */
    BOOL scanned;                   /* Has this entry been scanned? */
    BOOL negative;                  /* Is this entry used to rule out infections? */
    AVO_TYPE object_type;           /* The type of the object */
    AV_SCANERROR scan_result;       /* Error code resulting from the scan */
    DWORD flags;                    /* Flags related to the object */
	AV_DETECTREF detect_ref;        /* The reference of the current detection */
    AV_INFECTION_V2* infection;     /* The infection data for this object */
    char* path;                     /* The path of the scanned file */
    char* embedded_path;            /* The path of the scan object */
} AV_COMPONENTENTRY;

/* The package table */
typedef struct
{
    WORD structure_size;
    DWORD package_id;               /* ID of the package */
    WORD ncomponents;               /* Number of component entries */
    AV_COMPONENTENTRY** components; /* Array of ptrs to component entries */
} AV_PACKAGETABLE;

/* Structure to describe Scan Object containment to the engine */
/* It should be used to describe what the Scan Object has been extracted from:
   e.g. If it physically exists on disk and no unzipping has been performed
        then AV_CONTAINER_DISK should be supplied and no other codes */
typedef struct
{
    WORD structure_size;
    WORD count;                     /* The number of container codes present */
    DWORD *containers;              /* The container codes */
} AV_CONTAINERS;

/* Container codes */
#define AV_CONTAINER_OTHER  0       /* The scan object is contained in something
                                          that cannot be described to the engine */
#define AV_CONTAINER_DISK   1       /* The scan object is held on disk */
#define AV_CONTAINER_MIME   2       /* The scan object is held in a MIME file */
#define AV_CONTAINER_ZIP    3       /* The scan object is held in a ZIP file */

#if !defined UNIX
    /* Restore structure alignment where supported */
    #ifdef MacOS
       #pragma options align = reset
    #else
        #pragma pack()
    #endif
#endif


             
#ifdef __cplusplus
}
#endif

#endif



